daisy.ent.bdt <- daisy(int.dat.bp, metric = "manhattan")
agnes.daisy.ent.bdt <- agnes(daisy.ent.bdt, method = "complete")
agnes.daisy.ent.bdt <- agnes(daisy.ent.bdt, method = "ward")
plot(agnes.daisy.ent.bdt)
library(pvclust)
install.packages("pvclust")
library(pvclust)
ent.bdt.pvc <- pvclust(t(int.dat.bp), method.hclust = "ward", method.dist = "canberry")
ent.bdt.pvc <- pvclust(t(int.dat.bp), method.hclust = "ward", method.dist = "canberra")
warnings()
plot(ent.bdt.pvc)
ent.bdt.pvc <- pvclust(t(int.dat.bp), method.hclust = "ward", method.dist = "manhattan")
ent.bdt.pvc <- pvclust(t(int.dat.bp), method.hclust = "ward.D2", method.dist = "manhattan")
plot(ent.bdt.pvc)
ent.bdt.pvc <- pvclust(t(int.dat.bp), method.hclust = "ward.D2", method.dist = "euclidean")
plot(ent.bdt.pvc)
table(int.dat.split[1])
table(int.dat.split[7])
View(int.dat.split)
daisy.ent.bdt
dist.ent.bdt <- dist(int.dat.bp, method = "binary")
dist.ent.bdt
agnes.dist.ent.bdt <- agnes(dist.ent.bdt, method = "ward")
plot(agnes.dist.ent.bdt)
agnes.dist.ent.bdt <- agnes(dist.ent.bdt, method = "average")
plot(agnes.dist.ent.bdt)
agnes.dist.ent.bdt <- agnes(dist.ent.bdt, method = "single")
plot(agnes.dist.ent.bdt)
ent.bdt.pvc <- pvclust(t(int.dat.bp), method.hclust = "ward.D2", method.dist = "binary")
plot(ent.bdt.pvc)
library(extrafont)
install.packages("extrafont")
library(extrafont)
font_import()
loadfonts()
fonts()
agnes.dist.ent.bdt <- agnes(dist.ent.bdt, method = "ward", family = "Linux Libertine")
agnes.dist.ent.bdt <- agnes(dist.ent.bdt, method = "ward")
plot(agnes.dist.ent.bdt, family = "Linux Libertine")
agnes.dist.ent.bdt <- agnes(dist(int.dat.bp, method = "binary"), method = "ward")
plot(agnes.dist.ent.bdt, family = "Linux Libertine")
plot(hclust(dist(int.dat.bp, method = "binary"), method = "ward.D2"))
plot(hclust(dist(int.dat.bp, method = "binary"), method = "ward.D2"), family = "Linux Libertine")
plot(as.dendrogram(hclust(dist(int.dat.bp, method = "binary"), method = "ward.D2")), family = "Linux Libertine")
plot(as.dendrogram(hclust(dist(int.dat.bp, method = "binary"), method = "ward.D2")))
as.dendrogram(hclust(dist(int.dat.bp, method = "binary"), method = "ward.D2"))
library(ggplot2)
install.packages("ggdendro")
library(ggdendro)
dendro.clust <- ggdendrogram(hclust(dist(int.dat.bp, method = "binary"), method = "ward.D2"))
plot(dendro.clust)
plot(dendro.clust, family = "Linux Libertine")
print(dendro.clust)
print(dendro.clust, family = "Linux Libertine")
theme(text=element_text(family="Trebuchet MS"))
theme(text=element_text(family="Linux Libertine"))
print(dendro.clust, theme(text=element_text(family="Linux Libertine")))
print(dendro.clust)+theme(text=element_text(family="Linux Libertine"))
print(dendro.clust, rotate = T)+theme(text=element_text(family="Linux Libertine"))
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
print(dendro.clust, rotate = TRUE)
dendro.clust <- ggdendrogram(hclust(dist(int.dat.bp, method = "binary"), method = "ward.D2"), rotate = T)
print(dendro.clust, theme(text=element_text(family="Linux Libertine")))
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
dist.ent.bdt <- dist(int.dat.bp, method = "binary")
clust.ent.bdt <- hclust(dist.ent.bdt, method = "ward.D2")
plot(clust.ent.bdt)
dist.ent.bdt <- dist(int.dat.bp, method = "binary")
clust.ent.bdt <- hclust(dist.ent.bdt, method = "ward.D2")
dendro.clust <- ggdendrogram(clust.ent.bdt, rotate = T)
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
dendro.clust <- ggdendrogram(clust.ent.bdt, rotate = T, theme_dendro = F)
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
warnings()
dendro.clust <- ggdendrogram(clust.ent.bdt, rotate = T)
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
print(sank, file = "Sankey-Plot-bearb.html")
print(xtab.uebersicht.ent, tabular.environment = "longtable", booktabs = T, include.rownames = FALSE, floating = FALSE, caption.placement = "top")
print(xtab.uebersicht.bdt, tabular.environment = "longtable", booktabs = T, include.rownames = FALSE, floating = FALSE, caption.placement = "top")
View(interesting_data)
summary(interesting_data$ID)
dist.ent.bdt
round(dist.ent.bdt,2)
1/17
1-1/17
citation()
citation("extrafont")
int.dat.bp <- sapply(int.dat.bp, function(x) ifelse(x > 0, 1, 0))
int.dat.bp <- do.call(rbind, int.dat.split.bp)
int.dat.bp <- apply(int.dat.bp, function(x) ifelse(x > 0, 1, 0))
int.dat.bp <- do.call(rbind, int.dat.split.bp)
int.dat.bp <- lapply(int.dat.bp, function(x) ifelse(x > 0, 1, 0))
int.dat.bp <- do.call(rbind, int.dat.split.bp)
int.dat.bp <- do.call(function(x){ifelse(x > 0, 1, 0)}, int.dat.bp)
int.dat.bp <- do.call(rbind, int.dat.split.bp)
int.dat.bp <- eapply(int.dat.bp, function(x) ifelse(x > 0, 1, 0))
int.dat.bp <- tapply(int.dat.bp, function(x) ifelse(x > 0, 1, 0))
int.dat.bp <- do.call(rbind, int.dat.split.bp)
int.dat.bp <- tapply(int.dat.bp, function(x) ifelse(x > 0, 1, 0))
int.dat.bp <- do.call(rbind, int.dat.split.bp)
int.dat.bp[] <- lapply(int.dat.bp, function(x) ifelse(x > 0, 1, 0))
int.dat.bp <- do.call(rbind, int.dat.split.bp)
function(x) ifelse(x > 0, 1, 0)(7)
l <- c(1,2,3,0,0,4)
lapply(l, function(x) ifelse(x > 0, 1, 0))
int.dat.bp[] <- tapply(int.dat.bp, function(x) ifelse(x > 0, 1, 0))
View(int.dat.split.bp)
# Wenn es mehr als einen Faktor geben würde, den wir betrachten, wäre es bequemer Levshinas bp-Funktion zu nutzen.
# Diese ist aber auf Dataframes ausgerichtet und kommt mit einem einfachen Vektor nicht klar.
#int.dat.split.bp <- lapply(int.dat.split, bp)
int.dat.split.bp <- lapply(int.dat.split, table(x))
function(x)
# Wenn es mehr als einen Faktor geben würde, den wir betrachten, wäre es bequemer Levshinas bp-Funktion zu nutzen.
# Diese ist aber auf Dataframes ausgerichtet und kommt mit einem einfachen Vektor nicht klar.
#int.dat.split.bp <- lapply(int.dat.split, bp)
int.dat.split.bp <- lapply(int.dat.split, function(x) table(x))
int.dat.bp <- do.call(rbind, int.dat.split.bp)
# Wenn es mehr als einen Faktor geben würde, den wir betrachten, wäre es bequemer Levshinas bp-Funktion zu nutzen.
# Diese ist aber auf Dataframes ausgerichtet und kommt mit einem einfachen Vektor nicht klar.
#int.dat.split.bp <- lapply(int.dat.split, bp)
int.dat.split.bp <- lapply(int.dat.split, function(x) table(x))
int.dat.bp <- do.call(rbind, int.dat.split.bp)
View(int.dat.split)
# Wenn es mehr als einen Faktor geben würde, den wir betrachten, wäre es bequemer Levshinas bp-Funktion zu nutzen.
# Diese ist aber auf Dataframes ausgerichtet und kommt mit einem einfachen Vektor nicht klar.
#int.dat.split.bp <- lapply(int.dat.split, bp)
int.dat.split.bp <- lapply(int.dat.split, function(x){lapply(table(x), function(y) ifelse(y > 0, 1, 0))})
int.dat.bp <- do.call(rbind, int.dat.split.bp)
View(int.dat.split.bp)
# Das Vorgehen hier ist an die bei Levshina (2015, S. 305 f.) beschriebene Methode, Behavioural Profiles zu erstellen, angelehnt
# Es werden nur Entsprechungen und Bedeutungen genutzt, weil beim Rektionsstatus eigentlich nicht der Rektionsstatus selbst interessant wäre, sondern dessen Interaktion mit der Entsprechung (zwei regierte Präpositionen sind sich nicht unbedingt ähnlich im Ggs. zu zwei gleichen Entsprechungen)
# Splitten zu Liste, in der es für jede Bedeutung einen eigenen DF gibt
int.dat.split <- split(interesting_data[1:2], interesting_data$Bedeutung)
View(int.dat.split)
# Das Vorgehen hier ist an die bei Levshina (2015, S. 305 f.) beschriebene Methode, Behavioural Profiles zu erstellen, angelehnt
# Es werden nur Entsprechungen und Bedeutungen genutzt, weil beim Rektionsstatus eigentlich nicht der Rektionsstatus selbst interessant wäre, sondern dessen Interaktion mit der Entsprechung (zwei regierte Präpositionen sind sich nicht unbedingt ähnlich im Ggs. zu zwei gleichen Entsprechungen)
# Splitten zu Liste, in der es für jede Bedeutung einen eigenen DF gibt
int.dat.split <- split(interesting_data[1:2], interesting_data$Bedeutung)
View(int.dat.split)
# Entfernen der Bedeutungsspalte in jedem dieser DFs -> DFs werden zu Listen
int.dat.split <- lapply(int.dat.split, function(x) x = x[,-1])
View(int.dat.split)
#
int.dat.split.bin <- lapply(int.dat.split, function(x){lapply(table(x), function(y) ifelse(y > 0, 1, 0))})
int.dat.tab <- do.call(rbind, int.dat.split.bin)
# Das Vorgehen hier ist an die bei Levshina (2015, S. 305 f.) beschriebene Methode, Behavioural Profiles zu erstellen, angelehnt
# Es werden nur Entsprechungen und Bedeutungen genutzt, weil beim Rektionsstatus eigentlich nicht der Rektionsstatus selbst interessant wäre, sondern dessen Interaktion mit der Entsprechung (zwei regierte Präpositionen sind sich nicht unbedingt ähnlich im Ggs. zu zwei gleichen Entsprechungen)
# Splitten zu Liste, in der es für jede Bedeutung einen eigenen DF gibt
int.dat.split <- split(interesting_data[1:2], interesting_data$Bedeutung)
# Entfernen der Bedeutungsspalte in jedem dieser DFs -> DFs werden zu Listen, die die Entsprechungen enthalten
int.dat.split <- lapply(int.dat.split, function(x) x = x[,-1])
#
int.dat.split.bin <- lapply(int.dat.split, function(x){lapply(table(x), function(y) ifelse(y > 0, 1, 0))})
int.dat.tab <- do.call(rbind, int.dat.split.bin)
dist.ent.bdt <- dist(int.dat.bp, method = "binary")
clust.ent.bdt <- hclust(dist.ent.bdt, method = "ward.D2")
dendro.clust <- ggdendrogram(clust.ent.bdt, rotate = T)
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
plot(clust.ent.bdt)
dist.ent.bdt <- dist(int.dat.tab, method = "binary")
clust.ent.bdt <- hclust(dist.ent.bdt, method = "ward.D2")
dendro.clust <- ggdendrogram(clust.ent.bdt, rotate = T)
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
source('~/sciebo/Arbeit/Prep/Analyse.R')
for(i in nrow(int.dat.tab)){
print(i)
}
for(i in 1:nrow(int.dat.tab)){
print(i)
}
View(int.dat.tab)
# Das Vorgehen hier ist an die bei Levshina (2015, S. 305 f.) beschriebene Methode, Behavioural Profiles zu erstellen, angelehnt
# Es werden nur Entsprechungen und Bedeutungen genutzt, weil beim Rektionsstatus eigentlich nicht der Rektionsstatus selbst interessant wäre, sondern dessen Interaktion mit der Entsprechung (zwei regierte Präpositionen sind sich nicht unbedingt ähnlich im Ggs. zu zwei gleichen Entsprechungen)
# Splitten zu Liste, in der es für jede Bedeutung einen eigenen DF gibt
int.dat.split <- split(interesting_data[1:2], interesting_data$Bedeutung)
# Entfernen der Bedeutungsspalte in jedem dieser DFs -> DFs werden zu Listen, die die Entsprechungen enthalten
int.dat.split <- lapply(int.dat.split, function(x) x = x[,-1])
#
int.dat.split.bin <- lapply(int.dat.split, function(x){lapply(table(x), function(y) ifelse(y > 0, 1, 0))})
int.dat.tab <- do.call(rbind, int.dat.split.bin)
View(int.dat.split.bin)
int.dat.tab <- do.call(rbind, int.dat.split.bin)
View(int.dat.tab)
# Berechnen der Distanzen mit Jaccard-Metrik
dist.ent.bdt <- dist(int.dat.tab, method = "binary")
# Agglomeratives Clustering mit Ward-Methode
clust.ent.bdt <- hclust(dist.ent.bdt, method = "ward.D2")
plot(clust.ent.bdt)
dist.ent.bdt
str(int.dat.tab)
View(as.data.frame(int.dat.tab))
int.dat.tab <- as.data.frame(do.call(rbind, int.dat.split.bin))
# Berechnen der Distanzen mit Jaccard-Metrik
dist.ent.bdt <- dist(int.dat.tab, method = "binary")
# Agglomeratives Clustering mit Ward-Methode
clust.ent.bdt <- hclust(dist.ent.bdt, method = "ward.D2")
# Schöne Ausgabe als Dendrogramm (Damit das mit der Schriftart funktioniert, muss diese zuvor mit extrafont geladen werden)
dendro.clust <- ggdendrogram(clust.ent.bdt, rotate = T)
print(dendro.clust, rotate = TRUE)+theme(text=element_text(family="Linux Libertine"))
View(int.dat.tab)
entsubset <- function(row1, row2){
subset <- T
for(i in 1:length(row1)){
if(row1[i] == 1 && row2[i] == 0){
subset <- F
}
}
return(subset)
}
entsubset(int.dat.tab[,9], int.dat.tab[,8])
int.dat.tab[,9]
entsubset(int.dat.tab[9,], int.dat.tab[8,])
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
ent.obermengen <- ent.obermengen + rownames(int.dat.tab)[j]
}
}
print(bdt.name, ent.obermengen)
}
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
ent.obermengen <- c(ent.obermengen, rownames(int.dat.tab)[j])
}
}
print(bdt.name, ent.obermengen)
}
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
print(rownames(int.dat.tab)[j])
#ent.obermengen <- c(ent.obermengen, rownames(int.dat.tab)[j])
}
}
print(bdt.name, ent.obermengen)
}
a <- c()
b <- c(a, "b")
b
c <- c(b, rownames(int.dat.tab)[7])
c
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
ent.obermengen <- c(ent.obermengen, rownames(int.dat.tab)[j])
}
}
print(bdt.name, ent.obermengen)
}
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
ent.obermengen <- c(ent.obermengen, rownames(int.dat.tab)[j])
}
}
print(c(bdt.name, ent.obermengen))
}
entsprechungsobermengen <- list()
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
ent.obermengen <- c(ent.obermengen, rownames(int.dat.tab)[j])
}
}
entsprechungsobermengen[bdt.name] <- ent.obermengen
}
entsprechungsobermengen <- list(1:20)
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
ent.obermengen <- c(ent.obermengen, rownames(int.dat.tab)[j])
}
}
entsprechungsobermengen[bdt.name] <- ent.obermengen
}
entsprechungsobermengen <- list()
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
ent.obermengen <- c(ent.obermengen, rownames(int.dat.tab)[j])
}
}
entsprechungsobermengen[[bdt.name]] <- ent.obermengen
}
View(entsprechungsobermengen)
View(as.data.frame(entsprechungsobermengen))
View(t(as.data.frame(entsprechungsobermengen)))
entsprechungsobermengenausgabedf <- data.frame(Bedeutung = names(entsprechungsobermengen), EntsprTM = paste(entsprechungsobermengen, collapse = ", "))
View(entsprechungsobermengenausgabedf)
entsprechungsobermengenausgabedf <- data.frame(Bedeutung = names(entsprechungsobermengen), EntsprTM = entsprechungsobermengen)
entsprechungsobermengen[["Modal Art und Weise"]]
paste(entsprechungsobermengen[["Modal Art und Weise"]], collapse = ", ")
entsprechungsobermengenausgabedf <- data.frame(Bedeutung = names(entsprechungsobermengen), EntsprTM = lapply(entsprechungsobermengen, paste, collapse = ", "))
View(entsprechungsobermengenausgabedf)
entsprechungsobermengenausgabedf <- data.frame(Bedeutung = names(entsprechungsobermengen), EntsprTM = t(lapply(entsprechungsobermengen, paste, collapse = ", ")))
View(entsprechungsobermengenausgabedf)
lapply(entsprechungsobermengen, paste, collapse = ", ")
as.data.frame(lapply(entsprechungsobermengen, paste, collapse = ", "))
View(as.data.frame(lapply(entsprechungsobermengen, paste, collapse = ", ")))
View(t(as.data.frame(lapply(entsprechungsobermengen, paste, collapse = ", "))))
entsprechungsobermengenausgabedf <- t(as.data.frame(lapply(entsprechungsobermengen, paste, collapse = ", ")))
rownames(entsprechungsobermengenausgabedf) <- lapply(entsprechungsobermengenausgabedf, function(x) gsub(".", " ", x))
View(entsprechungsobermengen)
View(entsprechungsobermengenausgabedf)
rownames(entsprechungsobermengenausgabedf) <- lapply(entsprechungsobermengenausgabedf, function(x) gsub(".", " ", x, fixed = T))
entsprechungsobermengenausgabedf <- t(as.data.frame(lapply(entsprechungsobermengen, paste, collapse = ", ")))
rownames(entsprechungsobermengenausgabedf) <- lapply(entsprechungsobermengenausgabedf, function(x) gsub(".", " ", x, fixed = T))
View(entsprechungsobermengenausgabedf)
entsprechungsobermengen <- list()
for(i in 1:nrow(int.dat.tab)){
bdt.name <- rownames(int.dat.tab)[i]
ent.obermengen <- c()
for(j in 1:nrow(int.dat.tab)){
if(j != i && entsubset(int.dat.tab[i,], int.dat.tab[j,])){
ent.obermengen <- c(ent.obermengen, rownames(int.dat.tab)[j])
}
}
entsprechungsobermengen[[bdt.name]] <- ent.obermengen
}
entsprechungsobermengenausgabedf <- t(as.data.frame(lapply(entsprechungsobermengen, paste, collapse = ", ")))
rownames(entsprechungsobermengenausgabedf) <- lapply(entsprechungsobermengenausgabedf, function(x) gsub(".", " ", x, fixed = T))
View(entsprechungsobermengenausgabedf)
entsprechungsobermengenausgabedf <- t(as.data.frame(lapply(entsprechungsobermengen, paste, collapse = ", ")))
View(entsprechungsobermengenausgabedf)
rownames(entsprechungsobermengenausgabedf) <- lapply(rownames(entsprechungsobermengenausgabedf), function(x) gsub(".", " ", x, fixed = T))
xtable_entsprechungsobermengenausgabedf <- xtable(entsprechungsobermengenausgabedf, caption = "Bedeutungen, deren Entsprechungsmengen Teilmengen der Entsprechungsmengen anderer Bedeutungen sind", label = "entsprechungsmengen")
print(xtable_entsprechungsobermengenausgabedf, auto = TRUE, caption.placement = "top", booktabs = T)
colnames(entsprechungsobermengenausgabedf) <- c("Bedeutung", "Bedeutungen, deren Entsprechungsmengen Obermengen dieser Bedeutung sind")
xtable_entsprechungsobermengenausgabedf <- xtable(entsprechungsobermengenausgabedf, caption = "Bedeutungen, deren Entsprechungsmengen Teilmengen der Entsprechungsmengen anderer Bedeutungen sind", label = "entsprechungsmengen")
print(xtable_entsprechungsobermengenausgabedf, auto = TRUE, caption.placement = "top", booktabs = T)
colnames(entsprechungsobermengenausgabedf) <- c("Bedeutungen, deren Entsprechungsmengen Obermengen dieser Bedeutung sind")
xtable_entsprechungsobermengenausgabedf <- xtable(entsprechungsobermengenausgabedf, caption = "Bedeutungen, deren Entsprechungsmengen Teilmengen der Entsprechungsmengen anderer Bedeutungen sind", label = "entsprechungsmengen")
print(xtable_entsprechungsobermengenausgabedf, auto = TRUE, caption.placement = "top", booktabs = T)
source('~/sciebo/Arbeit/Prep/Analyse_ohne_Zusammenfuehrungen.R')
summary(de.ohne.1_3$Bedeutung)
for(bdtkomb in names(summary(de.ohne.1_3$Bedeutung))){
print(strsplit(bdtkomb, ",")[[1]])
}
bdts <- c()
for(bdtkomb in names(summary(de.ohne.1_3$Bedeutung))){
bdts <- c(bdts, print(strsplit(bdtkomb, ",")[[1]]))
}
bdts <- c()
for(bdtkomb in names(summary(de.ohne.1_3$Bedeutung))){
bdts <- c(bdts, strsplit(bdtkomb, ",")[[1]])
}
bdts
bdts <- unique(bdts)
bdts
bdtmatrix <- matrix(0, nrow = length(de.ohne.1_3$Bedeutung), ncol = length(bdts))
View(bdtmatrix)
bdtmatrix <- matrix(0, nrow = length(de.ohne.1_3$Bedeutung), ncol = length(bdts))
for(i in length(de.ohne.1_3$Bedeutung)){
for(j in bdts){
if(bdts[j] %in% strsplit(de.ohne.1_3$Bedeutung[i], ",")[[1]]){
bdtmatrix[i,j] <- 1
}
}
}
de.ohne.1_3$Bedeutung[8]
str(de.ohne.1_3$Bedeutung[8])
class(de.ohne.1_3$Bedeutung[8])
bdtmatrix <- matrix(0, nrow = length(de.ohne.1_3$Bedeutung), ncol = length(bdts))
for(i in length(de.ohne.1_3$Bedeutung)){
for(j in bdts){
if(bdts[j] %in% strsplit(as.character(de.ohne.1_3$Bedeutung[i]), ",")[[1]]){
bdtmatrix[i,j] <- 1
}
}
}
View(bdtmatrix)
as.character(de.ohne.1_3$Bedeutung[8]
)
bdtmatrix <- matrix(0, nrow = length(de.ohne.1_3$Bedeutung), ncol = length(bdts))
for(i in length(de.ohne.1_3$Bedeutung)){
for(j in bdts){
if(as.character(bdts[j]) %in% strsplit(as.character(de.ohne.1_3$Bedeutung[i]), ",")[[1]]){
bdtmatrix[i,j] <- 1
}
}
}
View(bdtmatrix)
as.character(bdts[9])
strsplit(as.character(de.ohne.1_3$Bedeutung[6]), ",")[[1]])
strsplit(as.character(de.ohne.1_3$Bedeutung[6]), ",")[[1]]
View(de.ohne.1_3)
strsplit(as.character(de.ohne.1_3$Bedeutung[3]), ",")[[1]]
"9" %in% strsplit(as.character(de.ohne.1_3$Bedeutung[3]), ",")[[1]]
"9" %in% strsplit(as.character(de.ohne.1_3$Bedeutung[1]), ",")[[1]]
"8" %in% strsplit(as.character(de.ohne.1_3$Bedeutung[1]), ",")[[1]]
bdts <- unique(bdts)
bdtmatrix <- matrix(0, nrow = length(de.ohne.1_3$Bedeutung), ncol = length(bdts))
for(i in length(de.ohne.1_3$Bedeutung)){
for(j in bdts){
if(as.character(bdts[j]) %in% strsplit(as.character(de.ohne.1_3$Bedeutung[i]), ",")[[1]]){
bdtmatrix[i,j] <- 1
print(bdtmatrix[i,j])
}
}
}
for(i in length(de.ohne.1_3$Bedeutung)){
print(as.character(de.ohne.1_3$Bedeutung[i]))
for(j in bdts){
if(as.character(bdts[j]) %in% strsplit(as.character(de.ohne.1_3$Bedeutung[i]), ",")[[1]]){
bdtmatrix[i,j] <- 1
print(bdtmatrix[i,j])
}
}
}
for(i in 1:length(de.ohne.1_3$Bedeutung)){
for(j in 1:length(bdts)){
if(as.character(bdts[j]) %in% strsplit(as.character(de.ohne.1_3$Bedeutung[i]), ",")[[1]]){
bdtmatrix[i,j] <- 1
}
}
}
bdtspldf <- as.data.frame(bdtmatrix)
colnames(bdtspldf) <- as.character(bdts)
rownames(bdtspldf) <- rownames(de.ohne.1_3)
View(bdtspldf)
input.mi.bdt <- cbind.(en.ohne.1_3$Formulierung,bdtspldf)
input.mi.bdt <- cbind(en.ohne.1_3$Formulierung,bdtspldf)
View(input.mi.bdt)
MI.test(input.mi.bdt, 1, 19)
MI.test(input.mi.bdt, 1, 19, type = "bon")
MI.test(input.mi.bdt, 1, 19, type = "rs2")
MI.test(input.mi.bdt, 1, 19, type = "boot")
item.response.table(input.mi.bdt, 1, 19)
MI.test(input.mi.bdt, 1, 19, type = "rs2")
source('~/sciebo/Arbeit/Prep/Analyse_ohne_Zusammenfuehrungen.R')
source('~/sciebo/Arbeit/Masterarbeit/Auswertungsskripte/Analyse.R')
setwd("~/sciebo/Arbeit/Masterarbeit/Auswertungsskripte")
source('~/sciebo/Arbeit/Masterarbeit/Auswertungsskripte/Analyse.R')
table(interesting_data$Bedeutung, interesting_data$de_regiert)
table(interesting_data$Bedeutung, interesting_data$en_regiert)
table(interesting_data$Entsprechung, interesting_data$de_regiert)
table(interesting_data$Entsprechung, interesting_data$en_regiert)
t(table(interesting_data$Entsprechung, interesting_data$en_regiert))
rbind(t(table(interesting_data$Entsprechung, interesting_data$de_regiert)), t(table(interesting_data$Entsprechung, interesting_data$en_regiert)))
kreuztabelle_ent_reg <- rbind(t(table(interesting_data$Entsprechung, interesting_data$de_regiert)), t(table(interesting_data$Entsprechung, interesting_data$en_regiert)))
xtab.table.kreuztabelle_ent_reg <- xtable(kreuztabelle_ent_reg, auto = T, caption = "Kreuztabelle Rektionsstatus Entsprechungen", label = "tableEntRek")
print(xtab.table.kreuztabelle_ent_reg, caption.placement = "top", booktabs = T, rotate.colnames = T)
# Kreuztabellen für Bedeutung und Rektionsstatus aneinandergeklebt: Erst de, dann en
kreuztabelle_bdt_reg <- rbind(t(table(interesting_data$Entsprechung, interesting_data$de_regiert)), t(table(interesting_data$Entsprechung, interesting_data$en_regiert)))
xtab.table.kreuztabelle_bdt_reg <- xtable(kreuztabelle_ent_reg, auto = T, caption = "Kreuztabelle Rektionsstatus Entsprechungen", label = "tableEntRek")
print(xtab.table.kreuztabelle_bdt_reg, caption.placement = "top", booktabs = T, rotate.colnames = T)
# Kreuztabellen für Entsprechung und Rektionsstatus aneinandergeklebt: Erst de, dann en
kreuztabelle_ent_reg <- rbind(t(table(interesting_data$Entsprechung, interesting_data$de_regiert)), t(table(interesting_data$Entsprechung, interesting_data$en_regiert)))
xtab.table.kreuztabelle_ent_reg <- xtable(kreuztabelle_ent_reg, auto = T, caption = "Kreuztabelle Rektionsstatus Entsprechungen", label = "tableEntRek")
print(xtab.table.kreuztabelle_ent_reg, caption.placement = "top", booktabs = T, rotate.colnames = T)
# Kreuztabellen für Bedeutung und Rektionsstatus aneinandergeklebt: Erst de, dann en
kreuztabelle_bdt_reg <- rbind(t(table(interesting_data$Entsprechung, interesting_data$de_regiert)), t(table(interesting_data$Entsprechung, interesting_data$en_regiert)))
xtab.table.kreuztabelle_bdt_reg <- xtable(kreuztabelle_bdt_reg, auto = T, caption = "Kreuztabelle Rektionsstatus Bedeutungen", label = "tableBdtRek")
print(xtab.table.kreuztabelle_bdt_reg, caption.placement = "top", booktabs = T, rotate.colnames = T)
# Kreuztabellen für Bedeutung und Rektionsstatus aneinandergeklebt: Erst de, dann en
kreuztabelle_bdt_reg <- rbind(t(table(interesting_data$Bedeutung, interesting_data$de_regiert)), t(table(interesting_data$Bedeutung, interesting_data$en_regiert)))
xtab.table.kreuztabelle_bdt_reg <- xtable(kreuztabelle_bdt_reg, auto = T, caption = "Kreuztabelle Rektionsstatus Bedeutungen", label = "tableBdtRek")
print(xtab.table.kreuztabelle_bdt_reg, caption.placement = "top", booktabs = T, rotate.colnames = T)
source('~/sciebo/Arbeit/Masterarbeit/Auswertungsskripte/Analyse_ohne_Zusammenfuehrungen.R')
input.mi.bdtrek <- cbind(de.ohne.1_3$regiert,bdtspldf)
MI.test(input.mi.bdtrek, 1, ncol(bdtspldf), type = "bon")
input.mi.bdt
input.mi.bdtrek
# Funktion, die für zwei Bedeutungszeilen aus der fürs Clustering verwendeten Tabelle prüft, ob die Menge der Entsprechungen für die erste
# eine Teilmenge der Menge der Entsprechungen der zweiten ist
entsubset <- function(row1, row2){
subset <- T
for(i in 1:length(row1)){
if(row1[i] == 1 && row2[i] == 0){
subset <- F
}
}
return(subset)
}
source('~/sciebo/Arbeit/Masterarbeit/Auswertungsskripte/Analyse.R')
chisq.test(table.int.dat.ohne.dop.ohne.sekP, correct = F)
chisq.test(table.int.dat.ohne.dop.ohne.sekP, correct = F)
table.int.dat.ohne.dop.ohne.sekP
chisq.test(table.int.dat.ohne.dop.ohne.sekP, correct = F)$stdres
source('~/sciebo/Arbeit/Masterarbeit/Auswertungsskripte/Analyse_ohne_Zusammenfuehrungen.R')
source('~/sciebo/Arbeit/Masterarbeit/Auswertungsskripte/Analyse.R')
print(assocstats(de_en_reg_ohne_dop))
chisq.test(de_en_reg_ohne_dop, correct = F)
chisq.test(de_en_reg_ohne_dop)
chisq.test(de_en_reg_ohne_dop, correct = F)$stdres
chisq.test(table.int.dat.ohne.dop.ohne.sekP, correct = F)
chisq.test(table.int.dat.ohne.dop.ohne.sekP, correct = F)$stdres
source('~/sciebo/Arbeit/Überarbeitung Masterarbeit/Auswertungsskripte/Analyse.R')
# ZEILE MIT GESAMTANZAHL HÄNDISCH ERGÄNZEN
print(xtable_int_dat_bdt, auto = TRUE, include.rownames = FALSE, caption.placement = "top", booktabs = T)
print(xtab.uebersicht.amv.bdt, tabular.environment = "longtable", booktabs = T, include.rownames = FALSE, floating = FALSE, caption.placement = "top")
print(xtab.summary.amv.form, caption.placement = "top", booktabs = T)
source('~/sciebo/Arbeit/Überarbeitung Masterarbeit/Auswertungsskripte/Analyse_ohne_Zusammenfuehrungen.R')
print(xtab.verteilungsuebersicht.kurz, include.rownames = FALSE, booktabs = T, include.colnames = F, caption.placement = "top")
